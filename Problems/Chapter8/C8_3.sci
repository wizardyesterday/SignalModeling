//**********************************************************************
// File Name: C8_3.sci
//**********************************************************************

// Bring in all of the utility functions.
exec('utils.sci',-1);

//**********************************************************************
// Mainline code.
//**********************************************************************

// We have a process y(n) = x(n) + w(n), where w(n) is white Gaussian
// noise with variance sigmaW^2, and x(n) is an AR(2) process that is
// generated by filtering unit variance noise with the filter,
// H(z) = 1/{1 -  1.585*z^(-1) + 0.96z^(-2)}.
// with unit variance white Gaussian noise.

// Create the filter.
a = [1 -1.585 0.96];
a = a(:);

//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
// Part (a): Plot the power spectrum of x(n) and y(n).  For this
// problem, let sigmaW^2 = 1.
//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
// Generate white noise sequence with unit variance.
noisegen(1,100,1);
v = feval([1:100],Noise);
v = v(:);

// Generate w(n) represented as unit variance Gaussian white noise.
w = feval([1:100],Noise);
w = w(:);

// Generate processes.
x = filterBlock(v,1,a(2:$));
y = x + w;

// Generate exact spectra.
Px = constructPowerSpectrum(x);
Py = constructPowerSpectrum(y);

//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
// Part (b): For sigmaW^2 = 0.5, 1, 2, 5, generate N = 100
// samples of the process y(n), and estimate the power spectrum
// of x(n) from y(n) using the maximum entropy method with p = 2.
//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
// Generate noise with a variance of 0.5.
noisegen(1,100,sqrt(0.5));
w_pt5 = feval([1:100],Noise);
w_pt5 = w_pt5(:);

// Generate noise with a variance  of 1.
noisegen(1,100,1);
w_1 = feval([1:100],Noise);
w_1 = w_1(:);

// Generate noise with a variance of 2.
noisegen(1,100,sqrt(2));
w_2 = feval([1:100],Noise);
w_2 = w_2(:);

// generate noise with a variance of 5.
noisegen(1,100,sqrt(5));
w_5 = feval([1:100],Noise);
w_5 = w_5(:);

// Generate noisy processes.
yb_pt5 = x + w_pt5;
yb_1 = x + w_1;
yb_2 = x + w_2;
yb_5 = x + w_5;

// Compute power spectrum estimates using the maximum entropy method.
Pyb_pt5 = mem(yb_pt5,2);
Pyb_1 = mem(yb_1,2);
Pyb_2 = mem(yb_2,2);
Pyb_5 = mem(yb_5,2);

//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
// Part (c): Repeat part (b) using the maximum entropy method
// with p = 5.
//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
// Compute power spectrum estimates using the maximum entropy method.
Pyc_pt5 = mem(yb_pt5,5);
Pyc_1 = mem(yb_1,5);
Pyc_2 = mem(yb_2,5);
Pyc_5 = mem(yb_5,5);

//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
// Part (d): Repeat parts (b) and (c) for the covariance,
// modified covariance, and Burg algorithms.  Which approach
// seems to be the best for a broadband autoregressive process?
// Note that 20 different realizations will be generated and
// estimates for p = 4, 6, 8, and 12 will be used.
//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

//*********************************************
// Plot results.
//*********************************************
// Select window 1.
//scf(1);

